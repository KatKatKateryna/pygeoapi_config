# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PygeoapiConfigDialog
                                 A QGIS plugin
 Update pygeoapi configuration file
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-05-16
        git sha              : $Format:%H$
        copyright            : (C) 2025 by ByteRoad
        email                : info@byteroad.net
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import yaml

from dataclasses import asdict

from .models.top_level.providers.records import ProviderTypes
from .models.top_level import InlineList

from qgis.core import (
    QgsMessageLog,
    QgsRasterLayer,
    QgsVectorLayer,
    QgsFeature,
    QgsGeometry,
    QgsRectangle,
    QgsProject,
    QgsCoordinateReferenceSystem,
    QgsFillSymbol,
)
from qgis.gui import QgsMapCanvas
from qgis.PyQt import QtWidgets, uic
from PyQt5.QtWidgets import (
    QFileDialog,
    QMessageBox,
    QDialogButtonBox,
    QApplication,
)  # or PyQt6.QtWidgets
from PyQt5.QtCore import (
    QFile,
    QTextStream,
    Qt,
    QStringListModel,
    QSortFilterProxyModel,
)  # Not strictly needed, can use Python file API instead

from .models.ConfigData import ConfigData
from .models.top_level import ResourceConfigTemplate, VisibilityTypes

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(
    os.path.join(os.path.dirname(__file__), "pygeoapi_config_dialog_base.ui")
)


class PygeoapiConfigDialog(QtWidgets.QDialog, FORM_CLASS):

    config_data = ConfigData()
    current_res_name = ""

    # these need to be class properties, otherwise, without constant reference, they are not displayed in a widget
    bbox_map_canvas: QgsMapCanvas
    bbox_base_layer: QgsRasterLayer
    bbox_extents_layer: QgsVectorLayer

    def __init__(self, parent=None):
        """Constructor."""
        super(PygeoapiConfigDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # make sure InlineList is represented as a YAML sequence (e.g. for 'bbox')
        yaml.add_representer(
            InlineList,
            lambda dumper, data: dumper.represent_sequence(
                "tag:yaml.org,2002:seq", data, flow_style=True
            ),
        )

        # custom assignments
        self.model = QStringListModel()
        self.proxy = QSortFilterProxyModel()

        # add default values to the UI
        self.fill_combo_box(
            self.comboBoxExceed, self.config_data.server.limits.on_exceed
        )
        self.fill_combo_box(self.comboBoxLog, self.config_data.logging.level)
        self.fill_combo_box(
            self.comboBoxMetadataIdKeywordsType,
            self.config_data.metadata.identification.keywords_type,
        )
        self.fill_combo_box(
            self.comboBoxMetadataContactRole, self.config_data.metadata.contact.role
        )

        self.config_data.set_ui_from_data(self)

        self._setup_map_widget()

    def save_to_file(self):

        # Set and validate data from UI
        try:
            self.config_data.set_data_from_ui(self)

            # validate mandatory fields before saving to file
            invalid_props = []
            invalid_props.extend(self.config_data.server.get_invalid_properties())
            invalid_props.extend(self.config_data.metadata.get_invalid_properties())

            if len(invalid_props) > 0:
                QgsMessageLog.logMessage(
                    f"Properties are missing or have invalid values: {invalid_props}"
                )
                QMessageBox.warning(
                    self,
                    "Warning",
                    f"Properties are missing or have invalid values: {invalid_props}",
                )
                return

        except Exception as e:
            QgsMessageLog.logMessage(f"Error deserializing: {e}")
            QMessageBox.warning(f"Error deserializing: {e}")
            return

        # Open dialog to set file path
        file_path, _ = QFileDialog.getSaveFileName(
            self, "Save File", "", "YAML Files (*.yml);;All Files (*)"
        )

        if file_path:
            QApplication.setOverrideCursor(Qt.WaitCursor)
            try:
                with open(file_path, "w", encoding="utf-8") as file:
                    yaml.dump(
                        self.config_data.asdict_enum_safe(self.config_data),
                        file,
                        default_flow_style=False,
                        sort_keys=False,
                        allow_unicode=True,
                    )
                QgsMessageLog.logMessage(f"File saved to: {file_path}")
            except Exception as e:
                QgsMessageLog.logMessage(f"Error saving file: {e}")
            finally:
                QApplication.restoreOverrideCursor()

    def open_file(self):
        file_name, _ = QFileDialog.getOpenFileName(
            self, "Open File", "", "YAML Files (*.yml);;All Files (*)"
        )

        if not file_name:
            return

        try:
            QApplication.setOverrideCursor(Qt.WaitCursor)
            with open(file_name, "r", encoding="utf-8") as file:
                file_content = file.read()

                # reset data
                self.config_data = ConfigData()
                self.config_data.set_data_from_yaml(yaml.safe_load(file_content))
                self.config_data.set_ui_from_data(self)

                # log messages about missing or mistyped values during deserialization
                QgsMessageLog.logMessage(
                    f"Errors during deserialization: {self.config_data.error_message}"
                )
                QgsMessageLog.logMessage(
                    f"Default values used for missing YAML fields: {self.config_data.defaults_message}"
                )

                # summarize all properties missing/overwitten with defaults
                # TODO: opportunity to match against the list of absolutely crucial properties
                # atm, warning with the full list of properties
                all_missing_props = self.config_data.all_missing_props
                QgsMessageLog.logMessage(
                    f"All missing or replaced properties: {self.config_data.all_missing_props}"
                )

                if len(all_missing_props) > 0:
                    QMessageBox.warning(
                        self,
                        "Warning",
                        f"All missing or replaced properties (check logs for more details): {self.config_data.all_missing_props}",
                    )

        except Exception as e:
            QMessageBox.warning(self, "Error", f"Cannot open file:\n{str(e)}")
        finally:
            QApplication.restoreOverrideCursor()

    def _select_listcollection_item_by_text(self, target_text: str):
        model = self.listViewCollection.model()
        for row in range(model.rowCount()):
            index = model.index(row, 0)
            if model.data(index) == target_text:
                self.listViewCollection.setCurrentIndex(index)
                break

    def _setup_resouce_loaded_ui(self, res_data: ResourceConfigTemplate):

        self.fill_combo_box(
            self.comboBoxResType,
            res_data.type,
        )
        self.fill_combo_box(
            self.comboBoxResVisibility,
            res_data.visibility
            or VisibilityTypes.DEFAULT,  # mock value, as default is None
        )
        self.fill_combo_box(
            self.comboBoxResProviderType,
            ProviderTypes.FEATURE,  # mock value if we don't yet have an object to get the value from
        )

    def _setup_map_widget(self):

        # Define base tile layer (OSM)
        urlWithParams = "type=xyz&url=https://tile.openstreetmap.org/{z}/{x}/{y}.png"
        self.bbox_base_layer = QgsRasterLayer(urlWithParams, "OpenStreetMap", "wms")

        # Create QgsMapCanvas with OSM layer
        self.bbox_map_canvas = QgsMapCanvas()
        crs = QgsCoordinateReferenceSystem("EPSG:4326")
        self.bbox_map_canvas.setDestinationCrs(crs)
        self.bbox_map_canvas.setCanvasColor(Qt.white)
        self.bbox_map_canvas.setLayers([self.bbox_base_layer])
        self.bbox_map_canvas.zoomToFullExtent()
        # self.canvas.setExtent(layer.extent(), True)
        # self.canvas.refreshAllLayers()

        # Add QgsMapCanvas as a widget to the Resource Tab
        self.bboxMapPlaceholder.addWidget(self.bbox_map_canvas)

    def fill_combo_box(self, combo_box, enum_class):
        """Set values to dropdown ComboBox, based on the values expected by the corresponding class."""

        combo_box.clear()
        for item in type(enum_class):
            combo_box.addItem(item.value)

    def on_button_clicked(self, button):

        role = self.buttonBox.buttonRole(button)
        print(f"Button clicked: {button.text()}, Role: {role}")

        # You can also check the standard button type
        if button == self.buttonBox.button(QDialogButtonBox.Save):
            self.save_to_file()
        elif button == self.buttonBox.button(QDialogButtonBox.Open):
            self.open_file()
        elif button == self.buttonBox.button(QDialogButtonBox.Close):
            self.reject()

    def open_templates_path_dialog(self):
        """Defining Server.templates.path path, called from .ui file."""

        folder_path = QFileDialog.getExistingDirectory(None, "Select Folder")

        if folder_path:
            self.lineEditTemplatesPath.setText(folder_path)

    def open_templates_static_dialog(self):
        """Defining Server.templates.static path, called from .ui file."""

        folder_path = QFileDialog.getExistingDirectory(None, "Select Folder")

        if folder_path:
            self.lineEditTemplatesStatic.setText(folder_path)

    def open_logfile_dialog(self):
        """Defining Logging.logfile path, called from .ui file."""

        logFile = QFileDialog.getSaveFileName(
            self, "Save Log", "", "log Files (*.log);;All Files (*)"
        )

        if logFile:
            self.lineEditLogfile.setText(logFile[0])

    def _lang_entry_exists_in_list_widget(self, list_widget, locale) -> bool:
        for i in range(list_widget.count()):
            if list_widget.item(i).text().startswith(f"{locale}: "):
                QMessageBox.warning(
                    self,
                    "Message",
                    f"Data entry in selected language already exists: {locale}",
                )
                return True
        return False

    def add_listwidget_element_from_lineedit(
        self,
        *,
        line_edit_widget,
        list_widget,
        locale_combobox=None,
        allow_repeated_locale=True,
        sort=True,
    ):
        """Take the content of LineEdit and add it as a new List entry."""

        text = line_edit_widget.text().strip()
        if text:

            text_to_print = text
            if locale_combobox:
                # get text with locale
                locale = locale_combobox.currentText()
                text_to_print = f"{locale}: {text}"

                # check if repeated language entries are allowed
                if allow_repeated_locale or not self._lang_entry_exists_in_list_widget(
                    list_widget, locale
                ):
                    list_widget.addItem(text_to_print)
                    line_edit_widget.clear()

            else:
                list_widget.addItem(text_to_print)
                line_edit_widget.clear()

            # sort the content
            if sort:
                list_widget.model().sort(0)

    def delete_list_widget_selected_item(self, list_widget):
        """Delete selected List item from widget."""
        selected_item = list_widget.currentRow()
        if selected_item >= 0:
            list_widget.takeItem(selected_item)

    def create_rect_layer_from_bbox(self, bbox: list[float], layer_name="Rectangle"):

        xmin, ymin, xmax, ymax = bbox
        # Create memory vector layer with polygon geometry
        layer = QgsVectorLayer("Polygon?crs=EPSG:4326", layer_name, "memory")
        provider = layer.dataProvider()
        crs = QgsCoordinateReferenceSystem("EPSG:4326")
        layer.setCrs(crs)

        # Create rectangular geometry from bbox
        rect = QgsRectangle(xmin, ymin, xmax, ymax)
        geom = QgsGeometry.fromRect(rect)

        # Create feature and assign geometry
        feature = QgsFeature()
        feature.setGeometry(geom)
        provider.addFeatures([feature])

        # Update layer
        layer.updateExtents()
        self.apply_red_transparent_style(layer)

        # QgsProject.instance().addMapLayer(layer)
        return layer

    def apply_red_transparent_style(self, layer):
        # Create a fill symbol with red color and 50% transparency
        symbol = QgsFillSymbol.createSimple(
            {
                "color": "255,0,0,80",  # Red fill with 128/255 alpha (50% transparent)
                "outline_color": "255,0,0, 128",  # Red outline
                "outline_width": "0.5",  # Outline width in mm
            }
        )

        # Apply symbol to layer renderer
        layer.renderer().setSymbol(symbol)
        layer.triggerRepaint()

    #################################################################
    ################## the methods called from .ui file
    #################################################################

    def add_metadata_id_title(self):
        """Add title to metadata, called from .ui file."""
        self.add_listwidget_element_from_lineedit(
            line_edit_widget=self.addMetadataIdTitleLineEdit,
            list_widget=self.listWidgetMetadataIdTitle,
            locale_combobox=self.comboBoxIdTitleLocale,
            allow_repeated_locale=False,
            sort=True,
        )

    def add_metadata_id_description(self):
        """Add description to metadata, called from .ui file."""
        self.add_listwidget_element_from_lineedit(
            line_edit_widget=self.addMetadataIdDescriptionLineEdit,
            list_widget=self.listWidgetMetadataIdDescription,
            locale_combobox=self.comboBoxIdDescriptionLocale,
            allow_repeated_locale=False,
            sort=True,
        )

    def add_metadata_keyword(self):
        """Add keyword to metadata, called from .ui file."""
        self.add_listwidget_element_from_lineedit(
            line_edit_widget=self.addMetadataKeywordLineEdit,
            list_widget=self.listWidgetMetadataIdKeywords,
            locale_combobox=self.comboBoxKeywordsLocale,
            allow_repeated_locale=True,
            sort=True,
        )

    def add_res_title(self):
        """Called from .ui file."""
        self.add_listwidget_element_from_lineedit(
            line_edit_widget=self.addResTitleLineEdit,
            list_widget=self.listWidgetResTitle,
            locale_combobox=self.comboBoxResTitleLocale,
            allow_repeated_locale=False,
            sort=True,
        )

    def add_res_description(self):
        """Called from .ui file."""
        self.add_listwidget_element_from_lineedit(
            line_edit_widget=self.addResDescriptionLineEdit,
            list_widget=self.listWidgetResDescription,
            locale_combobox=self.comboBoxResDescriptionLocale,
            allow_repeated_locale=False,
            sort=True,
        )

    def add_res_keyword(self):
        """Called from .ui file."""
        self.add_listwidget_element_from_lineedit(
            line_edit_widget=self.addResKeywordsLineEdit,
            list_widget=self.listWidgetResKeywords,
            locale_combobox=self.comboBoxResKeywordsLocale,
            allow_repeated_locale=True,
            sort=True,
        )

    def delete_metadata_id_title(self):
        """Delete keyword from metadata, called from .ui file."""
        self.delete_list_widget_selected_item(self.listWidgetMetadataIdTitle)

    def delete_metadata_id_description(self):
        """Delete keyword from metadata, called from .ui file."""
        self.delete_list_widget_selected_item(self.listWidgetMetadataIdDescription)

    def delete_metadata_keyword(self):
        """Delete keyword from metadata, called from .ui file."""
        self.delete_list_widget_selected_item(self.listWidgetMetadataIdKeywords)

    def delete_res_title(self):
        """Called from .ui file."""
        self.delete_list_widget_selected_item(self.listWidgetResTitle)

    def delete_res_description(self):
        """Called from .ui file."""
        self.delete_list_widget_selected_item(self.listWidgetResDescription)

    def delete_res_keyword(self):
        """Called from .ui file."""
        self.delete_list_widget_selected_item(self.listWidgetResKeywords)

    def filterResources(self, filter):
        """Called from .ui."""
        self.proxy.setDynamicSortFilter(True)
        self.proxy.setFilterFixedString(filter)

    def exit_resource_edit(self):
        """Switch widgets to Preview, reset selected resource. Called from .ui."""
        # hide detailed collection UI, show preview
        self.groupBoxCollectionLoaded.hide()
        self.groupBoxCollectionPreview.show()
        self.config_data.refresh_resources_list_ui(self)

    def save_resource_edit_and_preview(self):
        """Save current changes to the resource data, reset widgets to Preview. Called from .ui."""

        if self.current_res_name == "":
            QgsMessageLog.logMessage("Resource alias is missing")
            QMessageBox.warning(
                self,
                "Warning",
                "Resource alias is missing",
            )
            return

        self.config_data.set_resource_data_from_ui(self)

        # rename resource if alias changed
        new_alias = self.lineEditResAlias.text()

        # reset the current resource name, refresh UI list
        self.current_res_name = new_alias
        self.exit_resource_edit()

    def preview_resource(self, model_index: "QModelIndex"):
        """Display basic Resource info, called from .ui."""
        # if current resource already selected, do nothing
        new_res_name = model_index.data()
        if self.current_res_name == new_res_name:
            return

        # hide detailed collection UI, show preview
        self.groupBoxCollectionLoaded.hide()
        self.groupBoxCollectionPreview.show()

        self.current_res_name = new_res_name

        # If title is a dictionary, use the first (default) value
        title = self.config_data.resources[self.current_res_name].title
        if isinstance(title, dict):
            title = next(iter(title.values()), "")
        self.lineEditTitle.setText(title)

        # If description is a dictionary, use the first (default) value
        description = self.config_data.resources[self.current_res_name].description
        if isinstance(description, dict):
            description = next(iter(description.values()), "")
        self.lineEditDescription.setText(description)

        # load bbox
        bbox = self.config_data.resources[self.current_res_name].extents.spatial.bbox

        self.bbox_extents_layer = self.create_rect_layer_from_bbox(bbox)
        self.bbox_map_canvas.setLayers([self.bbox_extents_layer, self.bbox_base_layer])
        # self.bbox_map_canvas.zoomToFullExtent()
        self.bbox_map_canvas.setExtent(self.bbox_extents_layer.extent(), True)
        # self.canvas.refreshAllLayers()

    def newCollection(self):
        # add resource and reload UI
        new_name = self.config_data.add_new_resource()
        self.config_data.refresh_resources_list_ui(self)

        # select new resource
        self._select_listcollection_item_by_text(new_name)

        # set new resource as current and load details
        self.current_res_name = new_name
        self.loadCollection()

    def loadCollection(self):

        # if no resource selected, do nothing
        if self.current_res_name == "":
            return

        # hide preview collection UI, show detailed UI
        self.groupBoxCollectionPreview.hide()
        self.groupBoxCollectionLoaded.show()

        res_data = self.config_data.resources[self.current_res_name]
        self._setup_resouce_loaded_ui(res_data)

        # set the values to UI widgets
        self.config_data.set_resource_ui_from_data(self, res_data)

    def editCollectionTitle(self, value):
        QgsMessageLog.logMessage(f"Current collection - title: {self.current_res_name}")
        self.config_data.resources[self.current_res_name].title = value

    def editCollectionDescription(self, value):
        QgsMessageLog.logMessage(f"Current collection - desc: {self.current_res_name}")
        self.config_data.resources[self.current_res_name].description = value
