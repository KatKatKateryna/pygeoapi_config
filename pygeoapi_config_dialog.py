# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PygeoapiConfigDialog
                                 A QGIS plugin
 Update pygeoapi configuration file
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-05-16
        git sha              : $Format:%H$
        copyright            : (C) 2025 by ByteRoad
        email                : info@byteroad.net
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import yaml

from dataclasses import asdict
from .models.top_level import InlineList

from qgis.PyQt import uic
from qgis.core import QgsMessageLog
from qgis.PyQt import QtWidgets
from PyQt5.QtWidgets import (
    QFileDialog,
    QMessageBox,
    QDialogButtonBox,
    QApplication,
)  # or PyQt6.QtWidgets
from PyQt5.QtCore import (
    QFile,
    QTextStream,
    Qt,
    QStringListModel,
    QSortFilterProxyModel,
)  # Not strictly needed, can use Python file API instead

from .models.ConfigData import ConfigData

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(
    os.path.join(os.path.dirname(__file__), "pygeoapi_config_dialog_base.ui")
)


class PygeoapiConfigDialog(QtWidgets.QDialog, FORM_CLASS):

    config_data = ConfigData()
    cur_col_name = ""

    def __init__(self, parent=None):
        """Constructor."""
        super(PygeoapiConfigDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # make sure InlineList is represented as a YAML sequence (e.g. for 'bbox')
        yaml.add_representer(
            InlineList,
            lambda dumper, data: dumper.represent_sequence(
                "tag:yaml.org,2002:seq", data, flow_style=True
            ),
        )
        # add default values to the UI
        self.set_ui_from_config_data()

    def on_button_clicked(self, button):

        role = self.buttonBox.buttonRole(button)
        print(f"Button clicked: {button.text()}, Role: {role}")

        # You can also check the standard button type
        if button == self.buttonBox.button(QDialogButtonBox.Save):
            self.save_to_file()
        elif button == self.buttonBox.button(QDialogButtonBox.Open):
            self.open_file()
        elif button == self.buttonBox.button(QDialogButtonBox.Close):
            self.reject()

    def open_templates_path_dialog(self):
        """Defining Server.templates.path path, called from .ui file."""

        folder_path = QFileDialog.getExistingDirectory(None, "Select Folder")

        if folder_path:
            self.lineEditTemplatesPath.setText(folder_path)

    def open_templates_static_dialog(self):
        """Defining Server.templates.static path, called from .ui file."""

        folder_path = QFileDialog.getExistingDirectory(None, "Select Folder")

        if folder_path:
            self.lineEditTemplatesStatic.setText(folder_path)

    def open_logfile_dialog(self):
        """Defining Logging.logfile path, called from .ui file."""

        logFile = QFileDialog.getSaveFileName(
            self, "Save Log", "", "log Files (*.log);;All Files (*)"
        )

        if logFile:
            self.lineEditLogfile.setText(logFile[0])

    def write_yaml(self):

        try:

            # bind
            self.config_data.server.bind.host = self.lineEditHost.text()
            self.config_data.server.bind.port = self.spinBoxPort.value()

            # gzip
            self.config_data.server.gzip = self.checkBoxGzip.isChecked()

            # pretty print
            self.config_data.server.pretty_print = self.checkBoxPretty.isChecked()

            # admin
            self.config_data.server.admin = self.checkBoxAdmin.isChecked()

            # cors
            self.config_data.server.cors = self.checkBoxCors.isChecked()

            # templates
            self.config_data.server.templates.path = self.lineEditTemplatesPath.text()
            self.config_data.server.templates.static = (
                self.lineEditTemplatesStatic.text()
            )

            # map
            self.config_data.server.map.url = self.lineEditMapUrl.text()
            self.config_data.server.map.attribution = self.lineEditAttribution.text()

            # url
            self.config_data.server.url = self.lineEditUrl.text()

            # language
            self.config_data.server.languages = []
            for i in range(self.listWidgetLang.count()):
                item = self.listWidgetLang.item(i)
                if item.isSelected():
                    self.config_data.server.languages.append(item.text())

            # limits
            self.config_data.server.limits.default_items = self.spinBoxDefault.value()
            self.config_data.server.limits.max_items = self.spinBoxMax.value()

            self.config_data.server.limits.on_exceed = self.comboBoxExceed.currentText()

            # logging
            self.config_data.logging.level = self.comboBoxLog.currentText()
            self.config_data.logging.logfile = self.lineEditLogfile.text()
            self.config_data.logging.logformat = self.lineEditLogformat.text()
            self.config_data.logging.dateformat = self.lineEditDateformat.text()

        except Exception as e:
            QgsMessageLog.logMessage(f"Error deserializing: {e}")

    def save_to_file(self):

        file_path, _ = QFileDialog.getSaveFileName(
            self, "Save File", "", "YAML Files (*.yml);;All Files (*)"
        )

        if file_path:
            QApplication.setOverrideCursor(Qt.WaitCursor)
            try:
                with open(file_path, "w", encoding="utf-8") as file:
                    self.write_yaml()
                    yaml.dump(
                        asdict(self.config_data),
                        file,
                        default_flow_style=False,
                        sort_keys=False,
                    )
                QgsMessageLog.logMessage(f"File saved to: {file_path}")
            except Exception as e:
                QgsMessageLog.logMessage(f"Error saving file: {e}")
            finally:
                QApplication.restoreOverrideCursor()

    def open_file(self):
        file_name, _ = QFileDialog.getOpenFileName(
            self, "Open File", "", "YAML Files (*.yml);;All Files (*)"
        )

        if not file_name:
            return

        try:
            QApplication.setOverrideCursor(Qt.WaitCursor)
            with open(file_name, "r", encoding="utf-8") as file:
                file_content = file.read()

                # reset data
                self.config_data = ConfigData()
                self.config_data.set_data_from_yaml(yaml.safe_load(file_content))
                self.set_ui_from_config_data()
                QMessageBox.information(
                    self, "Message", f"{self.config_data.display_message}"
                )
                print(
                    self.config_data.display_message
                )  # printed, so it can be accessed later

        except Exception as e:
            QMessageBox.warning(self, "Error", f"Cannot open file:\n{str(e)}")
        finally:
            QApplication.restoreOverrideCursor()

    def select_items_by_text(list_widget, texts_to_select):
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            if item.text() in texts_to_select:
                item.setSelected(True)

    def set_ui_from_config_data(self):

        # bind
        self.lineEditHost.setText(self.config_data.server.bind.host)
        self.spinBoxPort.setValue(self.config_data.server.bind.port)

        # gzip
        self.checkBoxGzip.setChecked(self.config_data.server.gzip)

        # mimetype
        self._set_combo_box_value_from_data(
            combo_box=self.comboBoxMime,
            value=self.config_data.server.mimetype,
        )

        # encoding
        self._set_combo_box_value_from_data(
            combo_box=self.comboBoxEncoding,
            value=self.config_data.server.encoding,
        )

        # pretty print
        self.checkBoxPretty.setChecked(self.config_data.server.pretty_print)

        # admin
        self.checkBoxAdmin.setChecked(self.config_data.server.admin)

        # cors
        self.checkBoxCors.setChecked(self.config_data.server.cors)

        # templates
        self.lineEditTemplatesPath.setText(self.config_data.server.templates.path)
        self.lineEditTemplatesStatic.setText(self.config_data.server.templates.static)

        # map
        self.lineEditMapUrl.setText(self.config_data.server.map.url)
        self.lineEditAttribution.setText(self.config_data.server.map.attribution)

        self.lineEditUrl.setText(self.config_data.server.url)

        # language
        for i in range(self.listWidgetLang.count()):
            item = self.listWidgetLang.item(i)
            if item.text() in self.config_data.server.languages:
                item.setSelected(True)
            else:
                item.setSelected(False)

        # limits
        self.spinBoxDefault.setValue(self.config_data.server.limits.default_items)
        self.spinBoxMax.setValue(self.config_data.server.limits.max_items)

        self._set_combo_box_value_from_data(
            combo_box=self.comboBoxExceed,
            value=self.config_data.server.limits.on_exceed,
        )

        # logging
        self._set_combo_box_value_from_data(
            combo_box=self.comboBoxLog,
            value=self.config_data.logging.level,
        )

        self.lineEditLogfile.setText(self.config_data.logging.logfile)
        self.lineEditLogformat.setText(self.config_data.logging.logformat)
        self.lineEditDateformat.setText(self.config_data.logging.dateformat)

        # collections
        self.model = QStringListModel()
        self.model.setStringList([k for k, _ in self.config_data.resources.items()])

        self.proxy = QSortFilterProxyModel()
        self.proxy.setSourceModel(self.model)
        self.listViewCollection.setModel(self.proxy)

    def _set_combo_box_value_from_data(self, *, combo_box, value):
        """Set the combo box value based on the available choice and provided value."""

        for i in range(combo_box.count()):
            if combo_box.itemText(i) == value:
                combo_box.setCurrentIndex(i)
                return

        # If the value is not found, set to the first item or clear it
        if combo_box.count() > 0:
            combo_box.setCurrentIndex(0)
        else:
            combo_box.clear()

    def filterResources(self, filter):
        self.proxy.setDynamicSortFilter(True)
        self.proxy.setFilterFixedString(filter)

    def loadCollection(self, index: "QModelIndex"):
        self.cur_col_name = index.data()

        # If title is a dictionary, use the first (default) value
        title = self.config_data.resources[self.cur_col_name].title
        if isinstance(title, dict):
            title = next(iter(title.values()), "")
        self.lineEditTitle.setText(title)

        # If description is a dictionary, use the first (default) value
        description = self.config_data.resources[self.cur_col_name].description
        if isinstance(description, dict):
            description = next(iter(description.values()), "")
        self.lineEditDescription.setText(description)

    def editCollectionTitle(self, value):
        QgsMessageLog.logMessage(f"Current collection - title: {self.cur_col_name}")
        self.config_data.resources[self.cur_col_name].title = value

    def editCollectionDescription(self, value):
        QgsMessageLog.logMessage(f"Current collection - desc: {self.cur_col_name}")
        self.config_data.resources[self.cur_col_name].description = value
